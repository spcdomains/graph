{
    "sourceFile": "pages/Model/index.tsx",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1723809821706,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1723809863013,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,98 @@\n+import React, { useMemo, useRef, useEffect } from 'react';\r\n+import { Canvas, useFrame } from '@react-three/fiber';\r\n+import { OrbitControls } from '@react-three/drei';\r\n+import * as THREE from 'three';\r\n+\r\n+const NeuralLinks = () => {\r\n+  const sphereCount = 200; // Number of nodes\r\n+\r\n+  // Generate random node positions in a 3D space\r\n+  const spheres = useMemo(() => {\r\n+    const positions = [];\r\n+    for (let i = 0; i < sphereCount; i++) {\r\n+      const x = Math.random() * 200 - 100;\r\n+      const y = Math.random() * 200 - 100;\r\n+      const z = Math.random() * 200 - 100;\r\n+      positions.push({ position: [x, y, z] as [number, number, number], size: 1.0 }); // Explicitly type position\r\n+    }\r\n+    return positions;\r\n+  }, [sphereCount]);\r\n+\r\n+  // Generate connections between nodes\r\n+  const links = useMemo(() => {\r\n+    const result = [];\r\n+    for (let i = 0; i < sphereCount - 1; i++) {\r\n+      const start = spheres[i].position;\r\n+      const end = spheres[i + 1].position;\r\n+      result.push({ start, end });\r\n+    }\r\n+    // Optionally, connect the last node to the first one to close the loop\r\n+    // result.push({ start: spheres[sphereCount - 1].position, end: spheres[0].position });\r\n+    return result;\r\n+  }, [spheres, sphereCount]);\r\n+\r\n+  const meshRefs = useRef<THREE.Mesh<any, any>[]>([]);\r\n+\r\n+  useEffect(() => {\r\n+    meshRefs.current = meshRefs.current.slice(0, sphereCount);\r\n+  }, [sphereCount]);\r\n+\r\n+  useFrame(({ clock }: any) => {\r\n+    const time = clock.getElapsedTime();\r\n+    meshRefs.current.forEach((mesh) => {\r\n+      if (mesh) {\r\n+        mesh.rotation.y = time * 0.1;\r\n+        mesh.rotation.x = time * 0.05;\r\n+      }\r\n+    });\r\n+  });\r\n+\r\n+  // Create curved line\r\n+  const createCurvedLine = (start: [number, number, number], end: [number, number, number]) => {\r\n+    const curve = new THREE.QuadraticBezierCurve3(\r\n+      new THREE.Vector3(...start),\r\n+      new THREE.Vector3((start[0] + end[0]) / 2, (start[1] + end[1]) / 2 + Math.random() * 5, (start[2] + end[2]) / 2),\r\n+      new THREE.Vector3(...end)\r\n+    );\r\n+    const points = curve.getPoints(50);\r\n+    return new THREE.BufferGeometry().setFromPoints(points);\r\n+  };\r\n+\r\n+  return (\r\n+    <>\r\n+      {spheres.map((sphere, index) => (\r\n+        <mesh\r\n+          key={index}\r\n+          ref={(el:any) => (meshRefs.current[index] = el!)}\r\n+          position={sphere.position}\r\n+        >\r\n+          <sphereGeometry args={[1.0, 16, 16]} /> {/* Adjusted size */}\r\n+          <meshStandardMaterial color={`#d4ff00`} />\r\n+        </mesh>\r\n+      ))}\r\n+\r\n+      {links.map((link, index) => {\r\n+        const geometry = createCurvedLine(link.start, link.end);\r\n+        return (\r\n+          <line key={index}>\r\n+            <bufferGeometry attach=\"geometry\" {...geometry} />\r\n+            <lineBasicMaterial color=\"white\" linewidth={2} /> {/* Increased linewidth for visibility */}\r\n+          </line>\r\n+        );\r\n+      })}\r\n+    </>\r\n+  );\r\n+};\r\n+\r\n+const NeuralLinksModel = () => {\r\n+  return (\r\n+    <Canvas style={{ height: '100vh', width: '100vw', backgroundColor: '#000' }}>\r\n+      <ambientLight intensity={0.5} />\r\n+      <spotLight position={[10, 10, 10]} angle={0.15} penumbra={1} />\r\n+      <NeuralLinks />\r\n+      <OrbitControls />\r\n+    </Canvas>\r\n+  );\r\n+};\r\n+\r\n+export default NeuralLinksModel;\r\n"
                },
                {
                    "date": 1723811387107,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -95,102 +95,4 @@\n   );\r\n };\r\n \r\n export default NeuralLinksModel;\r\n-import React, { useMemo, useRef, useEffect } from 'react';\r\n-import { Canvas, useFrame } from '@react-three/fiber';\r\n-import { OrbitControls } from '@react-three/drei';\r\n-import * as THREE from 'three';\r\n-\r\n-const NeuralLinks = () => {\r\n-  const sphereCount = 200; // Number of nodes\r\n-\r\n-  // Generate random node positions in a 3D space\r\n-  const spheres = useMemo(() => {\r\n-    const positions = [];\r\n-    for (let i = 0; i < sphereCount; i++) {\r\n-      const x = Math.random() * 200 - 100;\r\n-      const y = Math.random() * 200 - 100;\r\n-      const z = Math.random() * 200 - 100;\r\n-      positions.push({ position: [x, y, z] as [number, number, number], size: 1.0 }); // Explicitly type position\r\n-    }\r\n-    return positions;\r\n-  }, [sphereCount]);\r\n-\r\n-  // Generate connections between nodes\r\n-  const links = useMemo(() => {\r\n-    const result = [];\r\n-    for (let i = 0; i < sphereCount - 1; i++) {\r\n-      const start = spheres[i].position;\r\n-      const end = spheres[i + 1].position;\r\n-      result.push({ start, end });\r\n-    }\r\n-    // Optionally, connect the last node to the first one to close the loop\r\n-    // result.push({ start: spheres[sphereCount - 1].position, end: spheres[0].position });\r\n-    return result;\r\n-  }, [spheres, sphereCount]);\r\n-\r\n-  const meshRefs = useRef<THREE.Mesh<any, any>[]>([]);\r\n-\r\n-  useEffect(() => {\r\n-    meshRefs.current = meshRefs.current.slice(0, sphereCount);\r\n-  }, [sphereCount]);\r\n-\r\n-  useFrame(({ clock }: any) => {\r\n-    const time = clock.getElapsedTime();\r\n-    meshRefs.current.forEach((mesh) => {\r\n-      if (mesh) {\r\n-        mesh.rotation.y = time * 0.1;\r\n-        mesh.rotation.x = time * 0.05;\r\n-      }\r\n-    });\r\n-  });\r\n-\r\n-  // Create curved line\r\n-  const createCurvedLine = (start: [number, number, number], end: [number, number, number]) => {\r\n-    const curve = new THREE.QuadraticBezierCurve3(\r\n-      new THREE.Vector3(...start),\r\n-      new THREE.Vector3((start[0] + end[0]) / 2, (start[1] + end[1]) / 2 + Math.random() * 5, (start[2] + end[2]) / 2),\r\n-      new THREE.Vector3(...end)\r\n-    );\r\n-    const points = curve.getPoints(50);\r\n-    return new THREE.BufferGeometry().setFromPoints(points);\r\n-  };\r\n-\r\n-  return (\r\n-    <>\r\n-      {spheres.map((sphere, index) => (\r\n-        <mesh\r\n-          key={index}\r\n-          ref={(el:any) => (meshRefs.current[index] = el!)}\r\n-          position={sphere.position}\r\n-        >\r\n-          <sphereGeometry args={[1.0, 16, 16]} /> {/* Adjusted size */}\r\n-          <meshStandardMaterial color={`#54f102`} />\r\n-        </mesh>\r\n-      ))}\r\n-\r\n-      {links.map((link, index) => {\r\n-        const geometry = createCurvedLine(link.start, link.end);\r\n-        return (\r\n-          <line key={index}>\r\n-            <bufferGeometry attach=\"geometry\" {...geometry} />\r\n-            <lineBasicMaterial color=\"white\" linewidth={2} /> {/* Increased linewidth for visibility */}\r\n-          </line>\r\n-        );\r\n-      })}\r\n-    </>\r\n-  );\r\n-};\r\n-\r\n-const NeuralLinksModel = () => {\r\n-  return (\r\n-    <Canvas style={{ height: '100vh', width: '100vw', backgroundColor: '#000' }}>\r\n-      <ambientLight intensity={0.5} />\r\n-      <spotLight position={[10, 10, 10]} angle={0.15} penumbra={1} />\r\n-      <NeuralLinks />\r\n-      <OrbitControls />\r\n-    </Canvas>\r\n-  );\r\n-};\r\n-\r\n-export default NeuralLinksModel;\r\n"
                }
            ],
            "date": 1723809821706,
            "name": "Commit-0",
            "content": "import React, { useMemo, useRef, useEffect } from 'react';\r\nimport { Canvas, useFrame } from '@react-three/fiber';\r\nimport { OrbitControls } from '@react-three/drei';\r\nimport * as THREE from 'three';\r\n\r\nconst NeuralLinks = () => {\r\n  const sphereCount = 200; // Number of nodes\r\n\r\n  // Generate random node positions in a 3D space\r\n  const spheres = useMemo(() => {\r\n    const positions = [];\r\n    for (let i = 0; i < sphereCount; i++) {\r\n      const x = Math.random() * 200 - 100;\r\n      const y = Math.random() * 200 - 100;\r\n      const z = Math.random() * 200 - 100;\r\n      positions.push({ position: [x, y, z] as [number, number, number], size: 1.0 }); // Explicitly type position\r\n    }\r\n    return positions;\r\n  }, [sphereCount]);\r\n\r\n  // Generate connections between nodes\r\n  const links = useMemo(() => {\r\n    const result = [];\r\n    for (let i = 0; i < sphereCount - 1; i++) {\r\n      const start = spheres[i].position;\r\n      const end = spheres[i + 1].position;\r\n      result.push({ start, end });\r\n    }\r\n    // Optionally, connect the last node to the first one to close the loop\r\n    // result.push({ start: spheres[sphereCount - 1].position, end: spheres[0].position });\r\n    return result;\r\n  }, [spheres, sphereCount]);\r\n\r\n  const meshRefs = useRef<THREE.Mesh<any, any>[]>([]);\r\n\r\n  useEffect(() => {\r\n    meshRefs.current = meshRefs.current.slice(0, sphereCount);\r\n  }, [sphereCount]);\r\n\r\n  useFrame(({ clock }: any) => {\r\n    const time = clock.getElapsedTime();\r\n    meshRefs.current.forEach((mesh) => {\r\n      if (mesh) {\r\n        mesh.rotation.y = time * 0.1;\r\n        mesh.rotation.x = time * 0.05;\r\n      }\r\n    });\r\n  });\r\n\r\n  // Create curved line\r\n  const createCurvedLine = (start: [number, number, number], end: [number, number, number]) => {\r\n    const curve = new THREE.QuadraticBezierCurve3(\r\n      new THREE.Vector3(...start),\r\n      new THREE.Vector3((start[0] + end[0]) / 2, (start[1] + end[1]) / 2 + Math.random() * 5, (start[2] + end[2]) / 2),\r\n      new THREE.Vector3(...end)\r\n    );\r\n    const points = curve.getPoints(50);\r\n    return new THREE.BufferGeometry().setFromPoints(points);\r\n  };\r\n\r\n  return (\r\n    <>\r\n      {spheres.map((sphere, index) => (\r\n        <mesh\r\n          key={index}\r\n          ref={(el:any) => (meshRefs.current[index] = el!)}\r\n          position={sphere.position}\r\n        >\r\n          <sphereGeometry args={[1.0, 16, 16]} /> {/* Adjusted size */}\r\n          <meshStandardMaterial color={`#54f102`} />\r\n        </mesh>\r\n      ))}\r\n\r\n      {links.map((link, index) => {\r\n        const geometry = createCurvedLine(link.start, link.end);\r\n        return (\r\n          <line key={index}>\r\n            <bufferGeometry attach=\"geometry\" {...geometry} />\r\n            <lineBasicMaterial color=\"white\" linewidth={2} /> {/* Increased linewidth for visibility */}\r\n          </line>\r\n        );\r\n      })}\r\n    </>\r\n  );\r\n};\r\n\r\nconst NeuralLinksModel = () => {\r\n  return (\r\n    <Canvas style={{ height: '100vh', width: '100vw', backgroundColor: '#000' }}>\r\n      <ambientLight intensity={0.5} />\r\n      <spotLight position={[10, 10, 10]} angle={0.15} penumbra={1} />\r\n      <NeuralLinks />\r\n      <OrbitControls />\r\n    </Canvas>\r\n  );\r\n};\r\n\r\nexport default NeuralLinksModel;\r\n"
        }
    ]
}